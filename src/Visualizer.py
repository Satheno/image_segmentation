import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from scipy.spatial.distance import cdist
from scipy.spatial.distance import norm


class Visualizer:

    def __init__(self, n_pixels: int, inverted_grey_values: bool, alpha_voxels: bool):
        """
        Base class of Visualizer objects
        """
        self._n_pixels = n_pixels
        self._inverted_grey_values = inverted_grey_values
        self._alpha_voxels = alpha_voxels
        if self._inverted_grey_values:
            self._noise_color = "#33333350" if self._alpha_voxels else "#333333"
            self._point_color = "#00000050" if self._alpha_voxels else "#000000"
            self._empty_color = "#FFFFFF02" if self._alpha_voxels else "#FFFFFF"
        else:
            self._noise_color = "#CCCCCC50" if self._alpha_voxels else "#CCCCCC"
            self._point_color = "#FFFFFF50" if self._alpha_voxels else "#FFFFFF"
            self._empty_color = "#00000002" if self._alpha_voxels else "#000000"

    def draw_original(self, instance, azim, elev):
        pass

    def _color_points(self, instance, fileld, colors):
        pass

    def draw_pixel(self, instance):
        dim = (self._n_pixels + 1, self._n_pixels + 1, self._n_pixels + 1)
        colors = np.full(dim, self._empty_color)
        filled = np.zeros(dim, dtype=np.bool) if self._inverted_grey_values else np.ones(dim, dtype=np.bool)

        self._color_points(instance, filled, colors)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        if self._alpha_voxels:
            # matplotlib bug workaround
            colors = self._explode(colors)
            filled = self._explode(filled)
            x, y, z = self._expand_coordinates(np.indices(np.array(filled.shape) + 1))

            ax.voxels(x, y, z, filled, facecolors=colors, edgecolors="#FFFFFF00", shade=False)
        else:
            ax.voxels(filled, facecolors=colors, edgecolors="#000000", shade=False)
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        plt.show()

    def _explode(self, data):
        """
        Internal helper function to work around a bug in matplotlib 3d, where transparent voxels don't render as
        expected. Faces of voxels on the inside of structures are not rendered correctly.
        """
        shape_arr = np.array(data.shape)
        size = shape_arr[:3] * 2 - 1
        exploded = np.zeros(np.concatenate([size, shape_arr[3:]]), dtype=data.dtype)
        exploded[::2, ::2, ::2] = data
        return exploded

    def _expand_coordinates(self, indices):
        """
        Internal helper function to work around a bug in matplotlib 3d, where transparent voxels don't render as
        expected. Faces of voxels on the inside of structures are not rendered correctly.
        """
        x, y, z = indices
        x[1::2, :, :] += 1
        y[:, 1::2, :] += 1
        z[:, :, 1::2] += 1
        return x, y, z


class CurveVisualizer(Visualizer):

    def __init__(self, n_pixels: int, noise: bool = True, inverted_grey_values: bool = True, alpha_voxels: bool = True):
        """
        Curve Visualizer object used to draw problem instances generated by the CurveDatasetGenerator. Two different
        ways of visualization are provided, e.g. the standard matplotlib visualization of curves using just the points
        of every curve in a problem instance (see draw_original) and a voxel based approximation of the curves with a
        resolution of <n_pixels> on every axis, i.e. <n_pixels>^3 voxels in total (see draw_pixel). The visualization
        scales up the problem instance to the given <n_pixels> on every axis.

        :param n_pixels: The number of pixels/voxels per axis in the draw_pixel visualization
            CAUTION: The np.arrays used to render the visualization will get huge, because of a bug workaround i used.
            Remember that the arrays grow cubic and through the workaround quintic i guess. Keep that in mind and use
            small values. 16, 32, 48 or 64 is fine but above could be problematic.

        :param noise: Whether the draw_pixel visualization should have some noise around the approximation or not

        :param inverted_grey_values: Whether the draw_pixel visualization should draw only the curves (with or without
            noise) (default -> True) or draw everything but the curves (-> False) CAUTION: Voxel Visualizations in
            matplotlib are very slow. Even if you use the default setting (True) the visualization will take quite long
            to render and the handling in the visualization itself is pretty bad and laggy. It is recommended to only
            use the value False if the resolution (<n_pixels>) is quite low, <noise> is False and if you don't have too
            much free space between curves, thus reducing the amount of voxels to render.
        """
        super().__init__(n_pixels, inverted_grey_values, alpha_voxels)
        self._noise = noise
        # TODO: Implement choice whether to use voxels with alpha or not (variant without alpha still missing)

    def draw_original(self, instance, azim=None, elev=None):
        """
        Simple function which draws the curves given in the instance the way they are defined, i.e. as lines.

        :param instance: The instance (dict) containing the curves to draw. keys should represent the curve ids and the
            associated values should be of shape (number_of_points_per_curve, 3)
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for curve_id, curve_points in instance.items():
            plt.plot(curve_points[:, 0], curve_points[:, 1], curve_points[:, 2])
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        ax.view_init(azim=azim, elev=elev)
        plt.show()

    def _color_point(self, colors, filled, point, color, offset=np.array([0, 0, 0])):
        """
        Internal function used to color voxels in the draw_pixel function and to color the noise voxels

        :param colors: The np.array containing the HTML color strings for every voxel
        :param filled: The np.array containing the presence information for every voxel (if a voxel is drawn or not)
        :param point: The coordinates of a voxel for the use in the colors/filled np.array
        :param color: The color the point will have in HTML format with alpha value --> #RRGGBBAA
        :param offset: The offset for the point. This is currently only used for adding noise
        :return: the altered colors, filled np.array
        """
        offset_point = point + offset
        if max(offset_point) < (len(colors) - 1) and min(offset_point) > 0 and \
                colors[offset_point[0]][offset_point[1]][offset_point[2]] != self._point_color:
            colors[offset_point[0]][offset_point[1]][offset_point[2]] = color
            filled[offset_point[0]][offset_point[1]][offset_point[2]] = 1

        return colors, filled

    def _color_points(self, instance, filled, colors):
        for i, (_, curve_points) in enumerate(instance.items()):
            curve_points *= self._n_pixels
            curve_points = curve_points.astype(np.int)
            for point in curve_points:
                colors, filled = self._color_point(colors, filled, point, self._point_color)
                # add noise (the 6 cubes around a point in this case)
                if self._noise:
                    for offset in [np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([0, 0, 1]), np.array([-1, 0, 0]),
                                   np.array([0, -1, 0]), np.array([0, 0, -1])]:
                        colors, filled = self._color_point(colors, filled, point, self._noise_color, offset=offset)

    def draw_pixel(self, instance):
        """
        Function used to draw a problem instance containing generated curves from the CurveDatasetGenerator.

        :param instance: The problem instance containing the dict of curve_ids as keys and curve points as associated
            values
        """


class VoronoiVisualizer(Visualizer):

    def __init__(self, n_pixels, inverted_grey_values: bool = True, max_dist: float = .005, alpha_voxels: bool = True):
        super().__init__(n_pixels, inverted_grey_values, alpha_voxels)
        self._max_dist = max_dist

    def draw_original(self, instance, azim=None, elev=None, boundary=False, center_nodes=False, faces=True):
        colors = ["#2F4F4F", "#228B22", "#800000", "#FFFF00", "#0000CD", "#00FF00", "#00FFFF", "#1E90FF",
                  "#FFDEAD", "#FF69B4"]
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for c_idx, cell in enumerate(instance):

            if boundary:
                # draw boundaries
                for v_start_idx, adj_idxs in enumerate(cell["adjacency"]):
                    for v_end_idx in adj_idxs:
                        line = np.append([cell["vertices"][v_start_idx]], [cell["vertices"][v_end_idx]], axis=0)
                        ax.plot(line[:, 0], line[:, 1], line[:, 2], c="#000000", ls="-", lw=1.)

            if center_nodes:
                # draw center node
                assert len(instance) <= len(colors)
                if len(cell["original"].shape) == 1:
                    center = np.array([cell["original"]])
                else:
                    center = cell["original"]
                ax.scatter(center[:, 0], center[:, 1], center[:, 2], c=colors[c_idx])

            if faces:
                # draw faces
                assert len(instance) <= len(colors)
                for face_dict in cell["faces"]:
                    points = np.array([[cell["vertices"][v_idx] for v_idx in face_dict["vertices"]]])
                    ax.add_collection3d(Poly3DCollection(points, alpha=.2, fc=colors[c_idx]))

        # axis labels
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        # set view
        ax.view_init(azim=azim, elev=elev)
        plt.show()

    def _color_points(self, instance, filled: np.array, colors: np.array):
        dim = filled.shape[0]
        originals = np.array([])
        originals_idxs = np.array([])
        for idx, cell in enumerate(instance):
            tmp_rows = [cell["original"]] if len(cell["original"].shape) == 1 else cell["original"]
            if len(originals) == 0:
                originals = tmp_rows
            else:
                originals = np.append(originals, tmp_rows, axis=0)
            originals_idxs = np.append(originals_idxs, np.full((len(tmp_rows),), idx))

        base_voxel = np.full((3,), 1 / dim)
        voxel_offset = np.full((3,), .5 / dim)
        for z_idx in range(dim):
            print(f"Z: {z_idx}")
            for y_idx in range(dim):
                for x_idx in range(dim):
                    current_voxel = base_voxel * np.array([x_idx, y_idx, z_idx]) + voxel_offset

                    # find cell and then subcell of voxel [x_idx, y_idx, z_idx]
                    original_distances = cdist(np.array([current_voxel]), originals)[0]
                    originals_min_idx = np.argmin(original_distances)
                    cell_idx = int(originals_idxs[originals_min_idx])
                    subcell_idx = int(originals_min_idx - np.where(originals_idxs == cell_idx)[0][0])

                    # find all faces belonging to the subcell and calculate the planes of these
                    subcell_faces = [face["vertices"] for face in instance[cell_idx]["faces"] if
                                     face["adjacent_cell"] >= 0 and
                                     np.allclose(face["original"], instance[cell_idx]["original"][subcell_idx])]
                    if len(subcell_faces) == 0:
                        # if there are no subcell faces then this cell is far from all boundaries -> voxel is white
                        continue
                    subcell_face_planes = []
                    cell = instance[cell_idx]
                    for v in subcell_faces:
                        cp = np.cross(cell["vertices"][v[2]] - cell["vertices"][v[0]],
                                      cell["vertices"][v[1]] - cell["vertices"][v[0]])
                        cp = cp / norm(cp)
                        subcell_face_planes.append(np.array([cp[0], cp[1], cp[2], cp.dot(cell["vertices"][v[2]])]))

                    # calculate distances to faces and color based on this distance
                    voxel_plane_dist = np.apply_along_axis(
                        lambda p: abs((p[:3].dot(current_voxel) - p[3]) / ((sum(p[:3] ** 2)) ** .5)),
                        1, subcell_face_planes)
                    min_dist = min(voxel_plane_dist)
                    if min_dist < self._max_dist:
                        color = 255 * (min_dist / self._max_dist) +128
                        color = 255 if color > 255 else color
                        if self._inverted_grey_values:
                            color = int(255 - color)
                        else:
                            color = int(color)
                        color = hex(color)[2:]
                        if len(color) == 1:
                            color = "0" + color
                        filled[x_idx][y_idx][z_idx] = True
                        colors[x_idx][y_idx][z_idx] = "#" + 3 * color + "50" if self._alpha_voxels else "#" + 3 * color
