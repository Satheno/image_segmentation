import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


class Visualizer:

    def __init__(self, n_pixels: int, inverted_grey_values: bool):
        """
        Base class of Visualizer objects
        """
        self._n_pixels = n_pixels
        self._inverted_grey_values = inverted_grey_values
        if self._inverted_grey_values:
            self._noise_color = "#33333350"
            self._point_color = "#00000050"
            self._empty_color = "#FFFFFF50"
        else:
            self._noise_color = "#CCCCCC50"
            self._point_color = "#FFFFFF50"
            self._empty_color = "#00000050"

    def draw_original(self, instance):
        pass

    def draw_pixel(self, instance):
        pass


class CurveVisualizer(Visualizer):

    def __init__(self, n_pixels: int, noise: bool = True, inverted_grey_values: bool = True):
        """
        Curve Visualizer object used to draw problem instances generated by the CurveDatasetGenerator. Two different
        ways of visualization are provided, e.g. the standard matplotlib visualization of curves using just the points
        of every curve in a problem instance (see draw_original) and a voxel based approximation of the curves with a
        resolution of <n_pixels> on every axis, i.e. <n_pixels>^3 voxels in total (see draw_pixel). The visualization
        scales up the problem instance to the given <n_pixels> on every axis.

        :param n_pixels: The number of pixels/voxels per axis in the draw_pixel visualization
            CAUTION: The np.arrays used to render the visualization will get huge, because of a bug workaround i used.
            Remember that the arrays grow cubic and through the workaround quintic i guess. Keep that in mind and use
            small values. 16, 32, 48 or 64 is fine but above could be problematic.

        :param noise: Whether the draw_pixel visualization should have some noise around the approximation or not

        :param inverted_grey_values: Whether the draw_pixel visualization should draw only the curves (with or without
            noise) (default -> True) or draw everything but the curves (-> False) CAUTION: Voxel Visualizations in
            matplotlib are very slow. Even if you use the default setting (True) the visualization will take quite long
            to render and the handling in the visualization itself is pretty bad and laggy. It is recommended to only
            use the value False if the resolution (<n_pixels>) is quite low, <noise> is False and if you don't have too
            much free space between curves, thus reducing the amount of voxels to render.
        """
        super().__init__(n_pixels, inverted_grey_values)
        self._noise = noise

    def draw_original(self, instance):
        """
        Simple function which draws the curves given in the instance the way they are defined, i.e. as lines.

        :param instance: The instance (dict) containing the curves to draw. keys should represent the curve ids and the
            associated values should be of shape (number_of_points_per_curve, 3)
        """
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        for curve_id, curve_points in instance.items():
            plt.plot(curve_points[:, 0], curve_points[:, 1], curve_points[:, 2])
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        plt.show()

    def _color_point(self, colors, filled, point, color, offset=np.array([0, 0, 0])):
        """
        Internal function used to color voxels in the draw_pixel function and to color the noise voxels

        :param colors: The np.array containing the HTML color strings for every voxel
        :param filled: The np.array containing the presence information for every voxel (if a voxel is drawn or not)
        :param point: The coordinates of a voxel for the use in the colors/filled np.array
        :param color: The color the point will have in HTML format with alpha value --> #RRGGBBAA
        :param offset: The offset for the point. This is currently only used for adding noise
        :return: the altered colors, filled np.array
        """
        offset_point = point + offset
        if max(offset_point) < (len(colors) - 1) and min(offset_point) > 0 and \
                colors[offset_point[0]][offset_point[1]][offset_point[2]] != self._point_color:
            colors[offset_point[0]][offset_point[1]][offset_point[2]] = color
            filled[offset_point[0]][offset_point[1]][offset_point[2]] = 1

        return colors, filled

    def draw_pixel(self, instance):
        """
        Function used to draw a problem instance containing generated curves from the CurveDatasetGenerator.

        :param instance: The problem instance containing the dict of curve_ids as keys and curve points as associated
            values
        """
        dim = (self._n_pixels + 1, self._n_pixels + 1, self._n_pixels + 1)
        colors = np.full(dim, self._empty_color)
        filled = np.zeros(dim, dtype=np.bool) if self._inverted_grey_values else np.ones(dim, dtype=np.bool)

        for i, (_, curve_points) in enumerate(instance.items()):
            curve_points *= self._n_pixels
            curve_points = curve_points.astype(np.int)
            for point in curve_points:
                colors, filled = self._color_point(colors, filled, point, self._point_color)
                # add noise (the 6 cubes around a point in this case)
                if self._noise:
                    for offset in [np.array([1, 0, 0]), np.array([0, 1, 0]), np.array([0, 0, 1]), np.array([-1, 0, 0]),
                                   np.array([0, -1, 0]), np.array([0, 0, -1])]:
                        colors, filled = self._color_point(colors, filled, point, self._noise_color, offset=offset)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        # matplotlib bug workaround
        colors = self._explode(colors)
        filled = self._explode(filled)
        x, y, z = self._expand_coordinates(np.indices(np.array(filled.shape) + 1))

        ax.voxels(x, y, z, filled, facecolors=colors, edgecolors="#FFFFFF00", shade=False)
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        plt.show()

    def _explode(self, data):
        """
        Internal helper function to work around a bug in matplotlib 3d, where transparent voxels don't render as
        expected. Faces of voxels on the inside of structures are not rendered correctly.
        """
        shape_arr = np.array(data.shape)
        size = shape_arr[:3] * 2 - 1
        exploded = np.zeros(np.concatenate([size, shape_arr[3:]]), dtype=data.dtype)
        exploded[::2, ::2, ::2] = data
        return exploded

    def _expand_coordinates(self, indices):
        """
        Internal helper function to work around a bug in matplotlib 3d, where transparent voxels don't render as
        expected. Faces of voxels on the inside of structures are not rendered correctly.
        """
        x, y, z = indices
        x[1::2, :, :] += 1
        y[:, 1::2, :] += 1
        z[:, :, 1::2] += 1
        return x, y, z


class VoronoiVisualizer(Visualizer):

    def __init__(self, n_pixels, inverted_grey_values: bool = True):
        super().__init__(n_pixels, inverted_grey_values)

    def draw_original(self, instance):
        pass

    def draw_pixel(self, instance):
        pass
